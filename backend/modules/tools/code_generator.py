from typing import List, Optional, Type, TypedDict
from langchain_openai import ChatOpenAI
from pydantic import BaseModel, Field
from langchain_core.tools import BaseTool
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain.callbacks.manager import (
    CallbackManagerForToolRun,
)

MAIN_PROMPT = ChatPromptTemplate.from_messages(  # type: ignore
            [
                (
                    "system",
                    """You are a coding assistant. \n 
            Here is a full set of a specific documentation:  \n ------- \n  || \n ------- \n Answer the user 
            question based on the above provided documentation. Ensure any code you provide can be executed \n 
            with all required imports and variables defined. Structure your answer with a description of the code solution. \n
            Then list the imports. And finally list the functioning code block. Here is the user question:""",
                ),
                MessagesPlaceholder(variable_name="chat_history"),
                ("human", "{messages}"),
            ]
        )

class CodeGenerationInput(BaseModel):
    query: str = Field(
        ...,
        title="description",
        description="A detailled prompt/ question to generate the code from. Takes into account the history of the chat.",
    )



class CodeGenerationOutput(BaseModel):
    """Code formatted Output"""

    prefix: str = Field(..., description="Description of the problem and approach")
    imports: str = Field(..., description="Code block import statements")
    code: str = Field(..., description="Code block not including import statements")
    # description: str = "Schema for code solutions to questions about the doc"

class AgentState(TypedDict):
    generation: CodeGenerationOutput
    #messages_seq: Annotated[Sequence[BaseMessage], operator.add]
    messages: List[str]
    iterations: int
    error: str

class CodeGeneratorTool(BaseTool):
    name = "code-generator"
    description = "useful for when you need to generate code from a prompt using a specific library."
    args_schema: Type[BaseModel] = CodeGenerationInput # type: ignore
    return_direct = True
    max_iterations: int = 3

    def _run(self, query: str, state: AgentState, model_function: ChatOpenAI, run_manager: Optional[CallbackManagerForToolRun] = None) -> AgentState:
        # State
        messages = state["messages"]
        iterations = state["iterations"]
        error = state["error"]

        # Check if we are called because of an error
        if error == "yes":
            messages += [
                (
                    "user",
                    "Now, try again. Invoke the code tool to structure the output with a prefix, imports, and code block:",
                )
            ]

        code_gen_chain = MAIN_PROMPT | model_function.with_structured_output(
            CodeGenerationOutput
        )

        # Solution
        if error != "no":
            code_solution = code_gen_chain.invoke(
                {"chat_history": [""], "messages": messages}
            )
        messages += [
            (
                "assistant",
                f"\n{code_solution['prefix']} \n Imports: {code_solution['imports']} \n Code: {code_solution['code']}",
            )
        ]

        # Increment
        iterations = iterations + 1
        return {
            "generation": code_solution,
            "messages": [msg[1] for msg in messages],
            "iterations": iterations,
            "error": ""
        }
    
    def _arun(self, query: str, state: AgentState, model_function: ChatOpenAI, run_manager: Optional[CallbackManagerForToolRun] = None):
        return self._run(query, state, model_function, run_manager)
    
class CodeCheckerTool(BaseModel):
    name = "code-generator"
    description = "useful for when you need to verify the code generated by Quivr."
    args_schema: Type[BaseModel] = AgentState # type: ignore
    return_direct = True
    max_iterations: int = 3

    def _run(self, state: AgentState, run_manager: Optional[CallbackManagerForToolRun] = None) -> AgentState:
        # State
        messages = state["messages"]
        code_solution = state["generation"]
        iterations = state["iterations"]
        #messages_seq = state["messages_seq"]

        # Get solution components
        # prefix = code_solution.prefix
        imports = code_solution.imports
        code = code_solution.code

        # Check imports
        try:
            exec(imports)
        except Exception as e:
            error_message = [("user", f"Your solution failed the import test: {e}")]
            messages += error_message
            return {
                "generation": code_solution,
                "messages": messages,
                "iterations": iterations,
                "error": "yes",
                #"messages_seq": messages_seq,
            }

        # Check execution
        try:
            exec(imports + "\n" + code)
        except Exception as e:
            error_message = [
                ("user", f"Your solution failed the code execution test: {e}")
            ]
            messages += error_message
            return {
                "generation": code_solution,
                "messages": messages,
                "iterations": iterations,
                "error": "yes",
            }

        # No errors
        return {
            "generation": code_solution,
            "messages": messages,
            "iterations": iterations,
            "error": "no",
        }
    
    def _arun(self,  state: AgentState, run_manager: Optional[CallbackManagerForToolRun] = None)-> AgentState:
        return self._run(state)

